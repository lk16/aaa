
fn todo {
    "TODO not implemented\n" .
}

fn test_drop {
    1 drop
}

fn test_dup {
    1 dup
    1 = assert
    1 = assert
}

fn test_over {
    1 2 over
    1 = assert
    2 = assert
    1 = assert
}

fn test_rot {
    1 2 3 rot
    1 = assert
    3 = assert
    2 = assert
}

fn test_swap {
    1 2 swap
    1 = assert
    2 = assert
}

fn test_nop {
    nop
}

fn test_subtract {
    3 2 -
    1 = assert
}

fn test_mutiply {
    3 2 *
    6 = assert
}

fn test_add {
    3 2 +
    5 = assert
}

fn test_divide_nonzero {
    7 3 /
    assert
    2 = assert
}

fn test_divide_zero {
    7 0 /
    not assert
    0 = assert
}

fn test_modulo_nonzero {
    7 3 %
    assert
    1 = assert
}

fn test_modulo_zero {
    7 0 %
    not assert
    0 = assert
}

fn test_int_equal_false {
    2 3 =
    not assert
}

fn test_int_equal_true {
    3 3 =
    assert
}

fn test_int_greater_true {
    3 2 >
    assert
}

fn test_int_greater_false_different {
    2 3 >
    not assert
}

fn test_int_greater_false_same {
    2 2 >
    not assert
}

fn test_int_less_true {
    2 3 <
    assert
}

fn test_int_less_false_different {
    3 2 <
    not assert
}

fn test_int_less_false_same {
    2 2 <
    not assert
}

fn test_int_less_equal_true_different {
    2 3 <=
    assert
}

fn test_int_less_equal_true_same {
    2 2 <=
    assert
}

fn test_int_less_equal_false {
    3 2 <=
    not assert
}

fn test_int_greater_equal_false {
    2 3 >=
    not assert
}

fn test_int_greater_equal_true_same {
    2 2 >=
    assert
}

fn test_int_greater_equal_true_different {
    3 2 >=
    assert
}

fn test_int_unequal_true {
    2 3 !=
    assert
}

fn test_int_unequal_false {
    2 2 !=
    not assert
}

fn test_and_true_true {
    true true and
    assert
}

fn test_and_true_false {
    true false and
    not assert
}

fn test_and_false_true {
    false true and
    not assert
}

fn test_and_false_false {
    false false and
    not assert
}

fn test_or_true_true {
    true true or
    assert
}

fn test_or_true_false {
    true false or
    assert
}

fn test_or_false_true {
    false true or
    assert
}

fn test_or_false_false {
    false false and
    not assert
}

fn test_not_true {
    true not
    not assert
}

fn test_not_false {
    false not
    assert
}

fn test_vec_print_zero_items {
    vec[int] repr
    "[]" str:equals assert
}

fn test_vec_print_one_item {
    vec[int] dup 1 vec:push repr
    "[1]" str:equals assert
}

fn test_vec_print_two_items {
    vec[int]
    dup 1 vec:push
    dup 2 vec:push
    repr
    "[1, 2]" str:equals assert
}

fn test_vec_print_nested_zero_items {
    vec[vec[int]] repr
    "[]" str:equals assert
}

fn test_vec_print_nested_one_item {
    vec[vec[int]]
    dup vec[int] vec:push repr
    "[[]]" str:equals assert
}

fn test_vec_pop_ok {
    vec[int]
    dup 5 vec:push
    dup vec:pop
    5 = assert
    repr "[]" str:equals assert // TODO use vector equality
}

fn test_vec_pop_fail {
    todo
}

fn test_vec_get_ok {
    vec[int]
    dup 5 vec:push
    dup 0 vec:get
    5 = assert
    repr "[5]" str:equals assert
}

fn test_vec_get_fail {
    todo
}

fn test_set_ok {
    vec[int]
    dup 5 vec:push
    dup 0 7 vec:set
    dup vec:pop
    7 = assert
    repr "[]" str:equals assert
}

fn test_set_fail {
    todo
}

fn test_vec_size_zero_items {
    vec[int] vec:size
    0 = assert
}

fn test_vec_size_one_item {
    vec[int]
    dup 5 vec:push
    vec:size
    1 = assert
}

fn test_vec_empty_false {
    vec[int]
    dup 5 vec:push
    vec:empty
    not assert
}

fn test_vec_empty_true {
    vec[int] vec:empty
    assert
}

fn test_vec_clear {
    vec[int]
    dup 5 vec:push
    dup vec:clear
    repr "[]" str:equals assert
}

fn test_vec_copy {
    todo
}

fn test_vec_dup {
    vec[int]
    dup 5 vec:push
    dup
    dup vec:clear
    vec:size
    0 = assert
    vec:size
    0 = assert
}

fn test_vec_nested_one_item {
    vec[vec[int]]
    dup
    vec[int]
    dup 5 vec:push
    vec:push
    repr "[[5]]" str:equals assert
}

fn test_map_print_zero_items {
    map[int, int] repr
    "{}" str:equals assert
}

fn test_map_print_nested {
    map[int, map[int, int]] repr
    "{}" str:equals assert
}

fn test_map_print_one_item {
    map[str, int]
    dup "one" 1 map:set
    repr
    "{\"one\": 1}" str:equals assert
}

fn test_map_get_set {
    map[str, int]
    dup "one" 1 map:set
    "one" map:get
    1 = assert
}

fn test_map_get_set_update {
    map[str, int]
    dup "one" 1 map:set
    dup "one" 2 map:set
    "one" map:get
    2 = assert
}

fn test_map_get_fail {
    todo
}

fn test_map_has_key_true {
    map[str, int]
    dup "one" 1 map:set
    "one" map:has_key
    assert
}

fn test_map_has_key_false {
    map[str, int]
    dup "one" 1 map:set
    "two" map:has_key
    not assert
}

fn test_map_size_one_item {
    map[str, int]
    dup "one" 1 map:set
    map:size
    1 = assert
}

fn test_map_size_zero_items {
    map[str, int]
    map:size
    0 = assert
}

fn test_map_empty_false {
    map[str, int]
    dup "one" 1 map:set
    map:empty
    not assert
}

fn test_map_empty_true {
    map[str, int]
    map:empty
    assert
}

fn test_map_clear {
    map[str, int]
    dup "one" 1 map:set
    dup map:clear
    map:size
    0 = assert
}

fn test_map_copy {
    todo
}

fn test_map_dup {
    map[str, int]
    dup "one" 1 map:set
    dup
    map:clear
    dup
    map:size
    0 = assert
    map:size
    0 = assert
}

fn test_map_pop_ok {
    map[str, int]
    dup "one" 1 map:set
    "one" map:pop
    1 = assert
}

fn test_map_pop_fail {
    todo
}

fn test_map_drop_ok {
    map[str, int]
    dup "one" 1 map:set
    dup "one" map:drop
    repr
    "{}" str:equals assert
}

fn test_map_drop_fail {
    todo
}


// TODO add tests for str
