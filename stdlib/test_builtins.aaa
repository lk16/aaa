
fn test_drop {
    1 drop
}

fn test_dup {
    1 dup
    1 = assert
    1 = assert
}

fn test_over {
    1 2 over
    1 = assert
    2 = assert
    1 = assert
}

fn test_rot {
    1 2 3 rot
    1 = assert
    3 = assert
    2 = assert
}

fn test_swap {
    1 2 swap
    1 = assert
    2 = assert
}

fn test_nop {
    nop
}

fn test_subtract {
    3 2 -
    1 = assert
}

fn test_mutiply {
    3 2 *
    6 = assert
}

fn test_add {
    3 2 +
    5 = assert
}

fn test_divide_nonzero {
    7 3 /
    assert
    2 = assert
}

fn test_divide_zero {
    7 0 /
    not assert
    0 = assert
}

fn test_modulo_nonzero {
    7 3 %
    assert
    1 = assert
}

fn test_modulo_zero {
    7 0 %
    not assert
    0 = assert
}

fn test_int_equal_false {
    2 3 =
    not assert
}

fn test_int_equal_true {
    3 3 =
    assert
}

fn test_int_greater_true {
    3 2 >
    assert
}

fn test_int_greater_false_different {
    2 3 >
    not assert
}

fn test_int_greater_false_same {
    2 2 >
    not assert
}

fn test_int_less_true {
    2 3 <
    assert
}

fn test_int_less_false_different {
    3 2 <
    not assert
}

fn test_int_less_false_same {
    2 2 <
    not assert
}

fn test_int_less_equal_true_different {
    2 3 <=
    assert
}

fn test_int_less_equal_true_same {
    2 2 <=
    assert
}

fn test_int_less_equal_false {
    3 2 <=
    not assert
}

fn test_int_greater_equal_false {
    2 3 >=
    not assert
}

fn test_int_greater_equal_true_same {
    2 2 >=
    assert
}

fn test_int_greater_equal_true_different {
    3 2 >=
    assert
}

fn test_int_unequal_true {
    2 3 !=
    assert
}

fn test_int_unequal_false {
    2 2 !=
    not assert
}

fn test_int_zero_value {
    int
    0 = assert
}

fn test_int_repr_positive {
    123 repr
    "123" str:equals assert
}

fn test_int_repr_negative {
    -123 repr
    "-123" str:equals assert
}

fn test_and_true_true {
    true true and
    assert
}

fn test_and_true_false {
    true false and
    not assert
}

fn test_and_false_true {
    false true and
    not assert
}

fn test_and_false_false {
    false false and
    not assert
}

fn test_or_true_true {
    true true or
    assert
}

fn test_or_true_false {
    true false or
    assert
}

fn test_or_false_true {
    false true or
    assert
}

fn test_or_false_false {
    false false and
    not assert
}

fn test_not_true {
    true not
    not assert
}

fn test_not_false {
    false not
    assert
}

fn test_bool_zero_value {
    bool
    not assert
}

fn test_bool_repr_true {
    true repr
    "true" str:equals assert
}

fn test_bool_repr_false {
    false repr
    "false" str:equals assert
}

fn test_vec_print_zero_items {
    vec[int] repr
    "[]" str:equals assert
}

fn test_vec_print_one_item {
    vec[int] dup 1 vec:push repr
    "[1]" str:equals assert
}

fn test_vec_print_two_items {
    vec[int]
    dup 1 vec:push
    dup 2 vec:push
    repr
    "[1, 2]" str:equals assert
}

fn test_vec_print_nested_zero_items {
    vec[vec[int]] repr
    "[]" str:equals assert
}

fn test_vec_print_nested_one_item {
    vec[vec[int]]
    dup vec[int] vec:push repr
    "[[]]" str:equals assert
}

fn test_vec_push_copy {
    3
    use x {
        vec[int]
        dup x vec:push
        x <- { 4 }
        0 vec:get
        3 = assert
    }
}

fn test_vec_push_twenty {
    vec[int]
    0
    while dup 20 < {
        over over vec:push
        1 +
    }
    drop

    0
    while dup 20 < {
        over over vec:get
        over = assert
        1 +
    }
    drop

    drop
}

fn test_vec_pop {
    vec[int]
    dup 5 vec:push
    dup vec:pop
    5 = assert
    repr "[]" str:equals assert
}

fn test_vec_get_copy {
    vec[int]
    use v {
        v 3 vec:push
        v 0 vec:get
        use x {
            x <- { 4 }
        }
        v 0 vec:get
        3 = assert
    }
}

fn test_vec_set {
    vec[int]
    dup 5 vec:push
    dup 0 7 vec:set
    dup vec:pop
    7 = assert
    repr "[]" str:equals assert
}

fn test_vec_set_copies {
    vec[int]
    dup 3 vec:push
    4
    use v, x {
        v 0 x vec:set
        x <- { 5 }
        v 0 vec:get
        4 = assert
    }
}

fn test_vec_size_zero_items {
    vec[int] vec:size
    0 = assert
}

fn test_vec_size_one_item {
    vec[int]
    dup 5 vec:push
    vec:size
    1 = assert
}

fn test_vec_empty_false {
    vec[int]
    dup 5 vec:push
    vec:empty
    not assert
}

fn test_vec_empty_true {
    vec[int] vec:empty
    assert
}

fn test_vec_clear {
    vec[int]
    dup 5 vec:push
    dup vec:clear
    repr "[]" str:equals assert
}

fn test_vec_copy {
    vec[int]
    dup vec:copy
    dup 5 vec:push
    vec:size 1 = assert
    vec:size 0 = assert
}

fn test_vec_dup {
    vec[int]
    dup 5 vec:push
    dup
    dup vec:clear
    vec:size
    0 = assert
    vec:size
    0 = assert
}

fn test_vec_nested_one_item {
    vec[vec[int]]
    dup
    vec[int]
    dup 5 vec:push
    vec:push
    repr "[[5]]" str:equals assert
}

fn test_map_set_copies {
    map[int, str] 0 "zero"
    use m, k, v {
        m k v map:set
        k <- { 1 }
        v <- {"one"}
        m repr "{0: \"zero\"}" str:equals assert
    }
}

fn test_map_print_zero_items {
    map[int, int] repr
    "{}" str:equals assert
}

fn test_map_print_nested {
    map[int, map[int, int]] repr
    "{}" str:equals assert
}

fn test_map_print_one_item {
    map[str, int]
    dup "one" 1 map:set
    repr
    "{\"one\": 1}" str:equals assert
}

fn test_map_print_two_items {
    map[str, int]
    dup "one" 1 map:set
    dup "two" 2 map:set
    repr

    dup "{\"one\": 1, \"two\": 2}" str:equals
    swap "{\"two\": 2, \"one\": 1}" str:equals
    or assert
}

fn test_map_twenty_items {
    map[int, int]
    0
    while dup 20 < {
        over over dup map:set
        1 +
    }
    drop

    0
    while dup 20 < {
        over over map:get
        assert
        over = assert
        1 +
    }
    drop

    drop
}

fn test_map_get_set {
    map[str, int]
    dup "one" 1 map:set
    "one" map:get assert
    1 = assert
}

fn test_map_get_copy {
    map[str, int]
    "one"
    use m, k {
        m k 1 map:set
        m k map:get
        assert
        use v {
            v <- { 2 }
        }
        m k map:get
        assert
        1 = assert
    }
}

fn test_map_get_set_update {
    map[str, int]
    dup "one" 1 map:set
    dup "one" 2 map:set
    "one" map:get
    assert
    2 = assert
}

fn test_map_get_fail {
    map[str, int]
    dup "one" 1 map:set
    "two" map:get
    not assert
    drop
}

fn test_map_has_key_true {
    map[str, int]
    dup "one" 1 map:set
    "one" map:has_key
    assert
}

fn test_map_has_key_false {
    map[str, int]
    dup "one" 1 map:set
    "two" map:has_key
    not assert
}

fn test_map_size_one_item {
    map[str, int]
    dup "one" 1 map:set
    map:size
    1 = assert
}

fn test_map_size_zero_items {
    map[str, int]
    map:size
    0 = assert
}

fn test_map_empty_false {
    map[str, int]
    dup "one" 1 map:set
    map:empty
    not assert
}

fn test_map_empty_true {
    map[str, int]
    map:empty
    assert
}

fn test_map_clear {
    map[str, int]
    dup "one" 1 map:set
    dup map:clear
    map:size
    0 = assert
}

fn test_map_copy {
    map[str, int]
    dup map:copy
    dup "one" 1 map:set
    map:size 1 = assert
    map:size 0 = assert
}

fn test_map_dup {
    map[str, int]
    dup "one" 1 map:set
    dup
    map:clear
    dup
    map:size
    0 = assert
    map:size
    0 = assert
}

fn test_map_pop_ok {
    map[str, int]
    dup "one" 1 map:set
    "one" map:pop assert
    1 = assert
}

fn test_map_pop_fail {
    map[str, int]
    dup "one" 1 map:set
    "two" map:pop not assert
    drop
}

fn test_map_drop_ok {
    map[str, int]
    dup "one" 1 map:set
    dup "one" map:drop
    assert
    repr
    "{}" str:equals assert
}

fn test_map_drop_fail {
    map[str, int]
    dup "one" 1 map:set
    dup "two" map:drop
    not assert
    drop
}

fn test_str_zero_value {
    str repr
    "\"\"" str:equals assert
}

fn test_str_split {
    "a b c" " " str:split
    repr
    "[\"a\", \"b\", \"c\"]" str:equals assert
}

fn test_str_substr_ok {
    "abcd" 1 3 str:substr
    assert
    "bc" str:equals assert
}

fn test_str_substr_fail_start {
    "abcd" -1 3 str:substr
    not assert
    "" str:equals assert
}

fn test_str_substr_fail_end {
    "abcd" 1 5 str:substr
    not assert
    "" str:equals assert
}

fn test_str_substr_fail_both {
    "abcd" -1 5 str:substr
    not assert
    "" str:equals assert
}

fn test_str_substr_start_after_end {
    "abcd" 2 1 str:substr
    not assert
    "" str:equals assert
}

fn test_str_len {
    "abcd" str:len
    4 = assert
}

fn test_str_upper {
    "abcd" str:upper
    "ABCD" str:equals assert
}

fn test_str_lower {
    "ABCD" str:lower
    "abcd" str:equals assert
}

fn test_str_find_ok {
    "abcd" "bc" str:find
    assert
    1 = assert
}

fn test_str_find_fail {
    "abcd" "x" str:find
    not assert
    0 = assert
}

fn test_str_find_after_ok {
    "abcd" "bc" 1 str:find_after
    assert
    1 = assert
}

fn test_str_find_after_fail {
    "abcd" "bc" 2 str:find_after
    not assert
    0 = assert
}

fn test_str_to_int_ok {
    "123" str:to_int
    assert
    123 = assert
}

fn test_str_to_int_fail {
    "1x23" str:to_int
    not assert
    0 = assert
}

fn test_str_join {
    "."
    vec[str]
    dup "a" vec:push
    dup "b" vec:push
    str:join
    "a.b" str:equals assert
}

fn test_str_equals_ok {
    "a" "a" str:equals
    assert
}

fn test_str_equals_fail {
    "a" "b" str:equals
    not assert
}

fn test_str_contains_ok {
    "abc" "b" str:contains
    assert
}

fn test_str_contains_fail {
    "abc" "d" str:contains
    not assert
}

fn test_str_to_bool_ok_true {
    "true" str:to_bool
    assert
    assert
}

fn test_str_to_bool_ok_false {
    "false" str:to_bool
    assert
    not assert
}

fn test_str_to_bool_fail {
    "foo" str:to_bool
    not assert
    not assert
}

fn test_str_replace {
    "abcd" "bc" "ef" str:replace
    "aefd" str:equals assert
}

fn test_str_append {
    "abcd" "ef" str:append
    "abcdef" str:equals assert
}

fn test_if_true {
    0
    if true {
        drop 1
    }

    1 = assert
}

fn test_if_false {
    0
    if false {
        drop 1
    }

    0 = assert
}

fn test_else_true {
    0
    if true {
        drop 1
    } else {
        drop 2
    }

    1 = assert
}

fn test_else_false {
    0
    if false {
        drop 1
    } else {
        drop 2
    }

    2 = assert
}

fn test_loop_false {
    0
    while false {
        drop 1
    }

    0 = assert
}

fn test_loop_true_false {
    0
    while dup 4 < {
        1 +
    }

    4 = assert
}

struct int_holder {
    value as int
}

fn test_struct_zero_value_int {
    int_holder "value" ?
    0 = assert
}

struct bool_holder {
    value as bool
}

fn test_struct_zero_value_bool {
    bool_holder "value" ?
    not assert
}

struct string_holder {
    value as str
}

fn test_struct_zero_value_str {
    string_holder "value" ?
    "" str:equals assert
}

struct vector_holder {
    value as vec[int]
}

fn test_struct_zero_value_vec {
    vector_holder "value" ?
    repr "[]" str:equals assert
}

struct map_holder {
    value as map[int, str]
}

fn test_struct_zero_value_map {
    map_holder "value" ?
    repr "{}" str:equals assert
}

struct indirect_int_holder {
    value as int_holder
}

fn test_struct_zero_value_struct {
    indirect_int_holder "value" ? "value" ?
    0 = assert
}

fn test_struct_set_get_int {
    int_holder
    dup "value" { 3 } !
    "value" ?

    3 = assert
}

fn test_struct_set_get_bool {
    bool_holder
    dup "value" { true } !
    "value" ?

    assert
}

fn test_struct_set_get_str {
    string_holder
    dup "value" { "foo" } !
    "value" ?

    "foo" str:equals assert
}

fn test_struct_set_get_vec {
    vector_holder
    dup "value" ?
    5 vec:push
    "value" ?

    repr "[5]" str:equals assert
}

// TODO #40 Add tests `set` functions
