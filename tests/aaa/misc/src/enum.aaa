

// Rust enum for comparison
// source: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html

// enum Message {
//     Quit,
//     Move { x: i32, y: i32 },
//     Write(String),
//     ChangeColor(i32, i32, i32),
// }

struct Coord {
    x as int,
    y as int,
}

struct Empty {}

struct Rgb {
    r as int,
    g as int,
    b as int,
}

enum Message {
    quit as Empty,
    move as Coord,
    write as str,
    change_color as Rgb,
}

fn is_quit_message args m as Message return bool {
    m
    match {
        case Message:quit { drop true }
        default { false }
    }
}

fn returns_sometimes args m as Message return int {
    m
    match {
        case Message:quit { 0 exit }
        case Message:move { drop 6 }
        case Message:write { 0 exit }
        case Message:change_color { drop 5 }
    }
}

fn main {
    // construct enum with attached values

    Rgb
    dup "r" { 1 } !
    dup "g" { 2 } !
    dup "b" { 3 } !
    Message:change_color
    // stack: Message:change_color{1, 2, 3}
    drop

    Coord
    dup "x" { 4 } !
    dup "y" { 5 } !
    Message:move
    // stack: Message:move{4, 5}
    drop

    "something"
    Message:write
    // stack: Message:written{"something"}
    drop

    Empty
    Message:quit
    // stack: Message
    drop

    Empty
    Message:quit

    match { // consumes Message
        case Message:quit {
            // stack: struct{}
            "quit\n" .

            drop
            // stack: <empty>
        }
        case Message:move {
            // stack: coord
            "move " .

            use c {
                c "x" ? .
                " " .
                c "y" ? .
            }
            "\n" .

            // stack: <empty>

        }
        case Message:write {
            // stack: str
            "write " .

            use w {
                w .
            }
            "\n" .

            // stack: <empty>
        }
        case Message:change_color {
            // stack: struct { r as int, g as int, y as int, }
            "color " .

            use c {
                c "r" ? .
                " " .
                c "g" ? .
                " " .
                c "b" ? .
            }
            "\n" .

            // stack: <empty>
        }
    }
    // stack: <empty>

    Empty
    Message:quit
    is_quit_message assert

    "something"
    Message:write
    is_quit_message not assert

}
