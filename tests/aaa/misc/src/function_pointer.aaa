
fn add args a as int, b as int, return int {
    a b +
}

fn calculate args a as int, b as int, callable as fn[int, int][int] return int {
   a b callable call
}

fn calculate_nested args a as int, b as int, callable as fn[int, int, fn[int, int][int]][int] return int {
    a b "add" fn callable call
}

fn get_add return fn[int, int][int] {
    "add" fn
}

enum OptionalCalculation {
    none,
    some as fn[int, int][int],
}

struct Foo {
    func as fn[int, int][int],
}

fn main {
    // call by function pointer
    34 35 "add" fn calculate .
    "\n" .

    // call by function pointer variable
    "add" fn
    use add_ {
        34 35 add_ call .
    }
    "\n" .

    // call by nested function pointer
    "add" fn
    "calculate" fn
    use add_, calculate_ {
        34 35 add_ calculate_ call .
    }
    "\n" .

    // call function with nested function pointer
    34 35 "calculate" fn calculate_nested .
    "\n" .

    // use function pointer with enum
    OptionalCalculation drop

    OptionalCalculation:none
    match {
        case OptionalCalculation:none { 69 }
        case OptionalCalculation:some { use func { 0 0 func call } }
    }
    .
    "\n" .


    "add" fn OptionalCalculation:some
    match {
        case OptionalCalculation:none { 0 }
        case OptionalCalculation:some { use func { 34 35 func call } }
    }
    .
    "\n" .

    "add" fn OptionalCalculation:some
    match {
        case OptionalCalculation:none { 0 }
        case OptionalCalculation:some as func { 34 35 func call }
    }
    .
    "\n" .

    // struct
    Foo
    use foo {
        foo "func" { "add" fn } !
        34 35 foo "func" ? call .
    }
    "\n" .

    // vector
    vec[fn[int, int][int]]
    use v {
        v "add" fn vec:push

        v
        foreach {
            use func {
                34 35 func call .
            }
        }
    }
    "\n" .

    // use stack and assign
    fn[int, int][int]
    use func {
        func <- { "add" fn }
        34 35 func call .
    }
    "\n" .

    // return function pointer from function
    34 35 get_add call .
    "\n" .
}

// TODO create function pointer to builtin function (special cases: `todo` and `unreachable`)

// TODO create function pointer to enum constructor

// TODO create function pointer to enum-associated function

// TODO create function pointer to struct-associated function

// TODO add python test for this file

// TODO add file that tests zero value for function pointer in enum
// The zero-value variant has default value of function pointer in associated value.
// This should default to some function that crashes loud.
enum Calculation {
    some as fn[int, int][int],
}

fn zero_value_in_enum {
    Calculation
    match {
        case Calculation:some as func { 34 35 func call drop }
    }
}

// TODO add file that tests zero value for function pointer in struct
fn zero_value_in_struct {
    34 35 Foo "func" ? call drop
}

// TODO add file that tests zero value for function pointer on the stack
fn zero_value_on_stack {
    34 35 fn[int, int][int] call drop
}

// TODO add file that uses pointer to function that never returns
fn does_not_return return never {
    "does_not_return was called!\n" .
    1 exit
}

fn call_does_not_return args func as fn[][never] return never {
    func call
}

fn use_does_not_return {
    fn[][never]
    use func {
        func <- { "does_not_return" fn }
        func call
    }
}
