
fn add args a as int, b as int, return int {
    a b +
}

fn calculate args a as int, b as int, callable as fn[int, int][int] return int {
   a b callable call
}

fn calculate_nested args a as int, b as int, callable as fn[int, int, fn[int, int][int]][int] return int {
    a b "add" fn callable call
}

fn get_add return fn[int, int][int] {
    "add" fn
}

enum OptionalCalculation {
    none,
    some as fn[int, int][int],
}

struct Foo {
    func as fn[int, int][int],
}

fn main {
    // call by function pointer
    34 35 "add" fn calculate .
    "\n" .

    // call by function pointer variable
    "add" fn
    use add_ {
        34 35 add_ call .
    }
    "\n" .

    // call by nested function pointer
    "add" fn
    "calculate" fn
    use add_, calculate_ {
        34 35 add_ calculate_ call .
    }
    "\n" .

    // call function with nested function pointer
    34 35 "calculate" fn calculate_nested .
    "\n" .

    // use function pointer with enum
    OptionalCalculation drop

    OptionalCalculation:none
    match {
        case OptionalCalculation:none { 69 }
        case OptionalCalculation:some { use func { 0 0 func call } }
    }
    .
    "\n" .


    "add" fn OptionalCalculation:some
    match {
        case OptionalCalculation:none { 0 }
        case OptionalCalculation:some { use func { 34 35 func call } }
    }
    .
    "\n" .

    "add" fn OptionalCalculation:some
    match {
        case OptionalCalculation:none { 0 }
        case OptionalCalculation:some as func { 34 35 func call }
    }
    .
    "\n" .

    // struct
    Foo
    use foo {
        foo "func" { "add" fn } !
        34 35 foo "func" ? call .
    }
    "\n" .

    // vector
    vec[fn[int, int][int]]
    use v {
        v "add" fn vec:push

        v
        foreach {
            use func {
                34 35 func call .
            }
        }
    }
    "\n" .

    // use stack and assign
    fn[int, int][int]
    use func {
        func <- { "add" fn }
        34 35 func call .
    }
    "\n" .

    // return function pointer from function
    34 35 get_add call .
    "\n" .

    // get pointer to builtin function
    69 "dup" fn call . drop
    "\n" .

    // get pointer to builtin member-function
    "6" "9" "str:append" fn call .
    "\n" .

    // get pointer to builtin function with unusual chars
    34 35 "+" fn call .
    "\n" .
}

// TODO create function pointer to enum-associated function

// TODO add python test for this file

// TODO create function pointer to imported function

// TODO add file that tests zero value for function pointer in enum
// The zero-value variant has default value of function pointer in associated value.
// This should default to some function that crashes loud.
enum Calculation {
    some as fn[int, int][int],
}

fn zero_value_in_enum {
    Calculation
    match {
        case Calculation:some as func { 34 35 func call drop }
    }
}

// TODO add file that tests zero value for function pointer in struct
fn zero_value_in_struct {
    34 35 Foo "func" ? call drop
}

// TODO add file that tests zero value for function pointer on the stack
fn zero_value_on_stack {
    34 35 fn[int, int][int] call drop
}

// TODO add file that uses pointer to function that never returns
fn does_not_return return never {
    "does_not_return was called!\n" .
    1 exit
}

fn call_does_not_return args func as fn[][never] return never {
    func call
}

fn use_does_not_return {
    fn[][never]
    use func {
        func <- { "does_not_return" fn }
        func call
    }
}

// TODO add file to use function pointer to enum constructor
// TODO extend this to use imported enum constructs as well
enum OptionalInt {
    none,
    some as int,
}

fn use_enum_ctor {
    "OptionalInt:none" fn
    use optional_int_none {
        optional_int_none call
        match {
            case OptionalInt:none { nop }
            default { unreachable }
        }
    }

    "OptionalInt:some" fn
    use optional_int_some {
        69 optional_int_some call
        match {
            case OptionalInt:some { . }
            default { unreachable }
        }
    }
    "\n" .
}

// TODO add test files for calling unusual builtin functions
fn unusual_functions {
    // TODO split this into 3 tests
    "todo" fn call
    // false "assert" fn call
    // "unreachable" fn call
}

// TODO create function pointer to struct-associated function
// TODO extend this to use imported struct-associated functions as well
struct Bar {
    value as int,
}

fn Bar:increment args bar as Bar {
    bar "value" { bar "value" ? 1 + } !
}

fn ptr_to_struct_func {
    Bar
    use bar {
        bar "value" { 68 } !
        "Bar:increment" fn
        use increment {
            bar increment call
        }
        bar "value" ? .
    }
    "\n" .
}
