
/// name: use builtin interface

fn main {
    "hello\n" .
    69 .
    "\n" .
}

/// stdout:
/// hello
/// 69

/// ----------------------------------------------------------------------------

/// name: use interface function as regular function

fn main {
    "hello\n" str:show .
    69 int:show .
    "\n" .
}

/// stdout:
/// hello
/// 69

/// ----------------------------------------------------------------------------

/// name: use interface function explicitly

fn main {
    "hello\n" Show:show .
    69 Show:show .
    "\n" .
}

/// stdout:
/// hello
/// 69

/// ----------------------------------------------------------------------------

/// name: use builtin interface on custom type

struct Foo {}

fn Foo:show args foo as Foo return str {
    "I am foo!"
}

fn main {
    Foo .
    "\n" .
}

/// stdout:
/// I am foo!

/// ----------------------------------------------------------------------------

/// name: use interface function explicitly on custom type

struct Foo {}

fn Foo:show args foo as Foo return str {
    "I am foo!"
}

fn main {
    Foo Show:show .
    "\n" .
}

/// stdout:
/// I am foo!

/// ----------------------------------------------------------------------------

/// name: use custom interface on custom type

interface Bar {
    fn Self:bar args self as Self return int
}

struct Foo {}

fn Foo:bar args foo as Foo return int {
    69
}

fn main {
    Foo Foo:bar .
    "\n" .
}

/// stdout:
/// 69

/// ----------------------------------------------------------------------------

/// name: use custom interface explicitly on custom type

interface Bar {
    fn Self:bar args self as Self return int
}

struct Foo {}

fn Foo:bar args foo as Foo return int {
    69
}

fn main {
    Foo Bar:bar .
    "\n" .
}

/// stdout:
/// 69

/// ----------------------------------------------------------------------------

/// name: use interface as argument type

fn show_twice args s as Show return str, str {
    s Show:show
    s Show:show
}

fn main {
    69 show_twice . .
    "\n" .
}

/// stdout:
/// 6969

/// ----------------------------------------------------------------------------

/// name: use interface as type param

fn main {
    vec[Show]
    dup 69 vec:push
    dup false vec:push
    .
    "\n" .
}

/// stdout:
/// [69, false]

/// ----------------------------------------------------------------------------

/// name: use vec int as vec show

fn show_vec args v as vec[Show] {
    v .
}

fn main {
    vec[int]
    dup 69 vec:push
    show_vec
    "\n" .
}

/// stdout:
/// [69]

// TODO add test for trying to use type with non-implemented trait
