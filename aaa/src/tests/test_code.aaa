/// name: nop

fn main {
    nop
}

/// ----------------------------------------------------------------------------

/// name: add ok

fn main {
    3 3 +
    drop
}

/// ----------------------------------------------------------------------------

/// name: add stack underflow

fn main {
    3 +
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:7: Stack underflow when calling +
///        stack: int
/// expected top: int int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: branch without else ok

fn main {
    if true {
        nop
    }
}

/// ----------------------------------------------------------------------------

/// name: branch with else ok

fn main {
    if true {
        nop
    } else {
        nop
    }
}

/// ----------------------------------------------------------------------------

/// name: branch without else fail

fn main {
    if true {
        3
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Mismatching branch types:
/// before stack:
///     if stack: int
///   else stack:
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: branch with else fail

fn main {
    if true {
        3
    } else {
        "hello"
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Mismatching branch types:
/// before stack:
///     if stack: int
///   else stack: str
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: branch with invalid condition

fn main {
    if 3 {
        nop
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:8: Unexpected stack after condition:
///   before:
///    after: int
/// expected: bool
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: while loop ok

fn main {
    while false {
        nop
    }
}

/// ----------------------------------------------------------------------------

/// name: while loop fail condition

fn main {
    while 3 {
        nop
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:11: Unexpected stack after condition:
///   before:
///    after: int
/// expected: bool
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: while loop fail body

fn main {
    while true {
        3
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Stack types changed in loop:
///   before:
///    after: int
/// expected:
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call function fail

fn main {
    3 "hello" +
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:15: Invalid stack when calling +
///        stack: int str
/// expected top: int int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call struct ok

fn main {
    vec[int] drop
}

/// ----------------------------------------------------------------------------

/// name: call struct with too many type parameters

fn main {
    vec[int, str]
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Unexpected number of parameters
///    Found: 2
/// Expected: 1
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call struct with too few type parameters

fn main {
    vec
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Unexpected number of parameters
///    Found: 0
/// Expected: 1
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call enum ok

enum Enum[T] {
    value
}

fn main {
    Enum[int] drop
}

/// ----------------------------------------------------------------------------

/// name: call enum with too many type parameters

enum Enum[T] {
    value
}

fn main {
    Enum[int, str]
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:5: Unexpected number of parameters
///    Found: 2
/// Expected: 1
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call enum with too few type parameters

enum Enum[T] {
    value
}

fn main {
    Enum
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:5: Unexpected number of parameters
///    Found: 0
/// Expected: 1
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: signature error

fn foo return bool {
    3
}

fn main {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: Computed stack types don't match signature for function "foo"
///    Found: int
/// Expected: bool
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: invalid stack on return

fn foo return bool {
    3 return
}

fn main {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:7: Invalid stack when using "return"
///    Found: int
/// Expected: bool
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: correct stack on return

fn foo return int, str {
    if true {
        69 "hello" return
    }
    unreachable
}

fn main {
    nop
}

/// ----------------------------------------------------------------------------

/// name: else with type never

fn main {
    if true {
        nop
    } else {
        unreachable
    }

    nop
}

/// ----------------------------------------------------------------------------

/// name: if with type never

fn main {
    if false {
        unreachable
    } else {
        nop
    }

    nop
}

/// ----------------------------------------------------------------------------

/// name: if with type never without else

fn main {
    if false {
        unreachable
    }

    nop
}

/// ----------------------------------------------------------------------------

/// name: if and else with type never

fn main {
    if true {
        unreachable
    } else {
        unreachable
    }

    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:7:5: Code is unreachable
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: use simple

fn main {
    3
    use x {
        x drop
    }
}

/// ----------------------------------------------------------------------------

/// name: use variable too early

fn main {
    3
    use x {
        nop
    }
    x
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:6:5: Unknown identifiable x
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: use fail variable too late

fn main {
    x
    3
    use x {
        nop
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Unknown identifiable x
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: use fail stack underflow

fn main {
    use x {
        nop
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Cannot use 1 value(s), because the stack is too small.
/// Stack:
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: use fail same variable reused with overlap

fn main {
    3
    use x {
        3
        use x {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// Found name collision:
/// $SOURCE_PATH/main.aaa:3:9: local variable x
/// $SOURCE_PATH/main.aaa:5:13: local variable x
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: use ok same variable reused without overlap

fn main {
    3
    use x {
        nop
    }

    3
    use x {
        nop
    }
}

/// ----------------------------------------------------------------------------

/// name: use fail argument name collision

fn main {
    nop
}

fn foo args x as int {
    3
    use x {
        nop
    }
}

/// status: 1

/// stderr:
/// Found name collision:
/// $SOURCE_PATH/main.aaa:4:13: argument x
/// $SOURCE_PATH/main.aaa:6:9: local variable x
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: use fail builtin function name collision

fn main {
    3
    use exit {
        nop
    }
}

/// status: 1

/// stderr:
/// Found name collision:
/// $AAA_STDLIB_PATH/builtins.aaa:161:1: function exit
/// $SOURCE_PATH/main.aaa:3:9: local variable exit
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: use fail builtin type name collision

fn main {
    3
    use vec {
        nop
    }
}

/// status: 1

/// stderr:
/// Found name collision:
/// $AAA_STDLIB_PATH/builtins.aaa:11:1: struct vec
/// $SOURCE_PATH/main.aaa:3:9: local variable vec
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: unexpected builtin function

fn main {
    nop
}

builtin fn foo

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:1: Found unexpected builtin function foo
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: unexpected builtin struct

fn main {
    nop
}

builtin struct bar

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:1: Found unexpected builtin struct bar
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: colliding struct and function

fn main {
    nop
}

struct main {}

/// status: 1

/// stderr:
/// Found name collision:
/// $SOURCE_PATH/main.aaa:1:1: function main
/// $SOURCE_PATH/main.aaa:4:1: struct main
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: cyclic import

from "foo" import bar

struct baz {}

fn main {
    nop
}

/// file: foo.aaa

from "main" import baz

struct bar {}

/// status: 1

/// stderr:
/// Found cyclic import:
/// $SOURCE_PATH/main.aaa
/// $SOURCE_PATH/foo.aaa
/// $SOURCE_PATH/main.aaa
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: missing import

from "foo" import bar

fn main {
    nop
}

/// file: foo.aaa

struct baz {}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: Cannot find bar in $SOURCE_PATH/foo.aaa.
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: import from non-existent file

from "foo" import bar

fn main {
    nop
}

/// status: 1

/// stderr:
/// Could not open $SOURCE_PATH/foo.aaa
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: indirect import

from "foo" import bar

fn main {
    nop
}

/// file: foo.aaa

from "bar" import bar

/// file: bar.aaa

struct bar {}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:19: Indirect imports are forbidden.
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: argument name collision with function

fn main {
    nop
}

fn bar args main as int {
    nop
}

/// status: 1

/// stderr:
/// Found name collision:
/// $SOURCE_PATH/main.aaa:1:1: function main
/// $SOURCE_PATH/main.aaa:4:13: argument main
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: invalid argument type

fn main {
    nop
}

fn bar args x as foo {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:18: Unknown identifiable foo
///
///Found 1 errors

/// ----------------------------------------------------------------------------

/// name: invalid argument param type

fn main {
    nop
}

fn bar args x as vec[Foo] {
    nop
}

/// stderr:
/// $SOURCE_PATH/main.aaa:4:22: Unknown identifiable Foo
///
///Found 1 errors

/// status: 1

/// ----------------------------------------------------------------------------

/// name: invalid return type

fn main {
    nop
}

fn bar return foo {
    nop
}

/// stderr:
/// $SOURCE_PATH/main.aaa:4:15: Unknown identifiable foo
///
///Found 1 errors

/// status: 1

/// ----------------------------------------------------------------------------

/// name: invalid return param type

fn main {
    nop
}

fn bar return vec[Foo] {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:19: Unknown identifiable Foo
///
///Found 1 errors

/// ----------------------------------------------------------------------------

/// name: get field ok

struct Foo {
    x as int
}

fn main {
    Foo "x" ? drop
}

/// ----------------------------------------------------------------------------

/// name: get field fail stack underflow

fn main {
    "x" ?
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Cannot get field x, because the stack is empty
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: get field fail enum

enum Foo {
    x as int
}

fn main {
    Foo "x" ? drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:9: Can only get field x from a struct, found enum Foo
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: get field fail field not found

struct Foo {
    x as int
}

fn main {
    Foo "y" ? drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:9: Cannot get field y from struct Foo, because it doesn't exist
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: set field ok

struct Foo {
    x as int
}

fn main {
    Foo "x" { 3 } !
}

/// ----------------------------------------------------------------------------

/// name: set field fail stack underflow

fn main {
    "x" { 3 } !
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Cannot set field x, because the stack is empty
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: set field fail enum

enum Foo {
    x as int
}

fn main {
    Foo "x" { 3 } !
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:9: Can only set field x on a struct, found enum Foo
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: set field fail field not found

struct Foo {
    x as int
}

fn main {
    Foo "y" { 3 } !
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:9: Cannot set field y on struct Foo, because it doesn't exist
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: set field fail expression is empty stack

struct Foo {
    x as int
}

fn main {
    Foo "x" { nop } !
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:9: Invalid stack types when setting field x on struct Foo:
///    Found:
/// Expected: int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: set field fail expression is wrong type

struct Foo {
    x as int
}

fn main {
    Foo "x" { "foo" } !
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:9: Invalid stack types when setting field x on struct Foo:
///    Found: str
/// Expected: int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: set field fail expression is multiple values

struct Foo {
    x as int
}

fn main {
    Foo "x" { 3 3 } !
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:9: Invalid stack types when setting field x on struct Foo:
///    Found: int int
/// Expected: int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: assign local variable ok

fn main {
    3
    use x {
        x <- { 4 }
    }
}

/// ----------------------------------------------------------------------------

/// name: assign local variable fail too many values

fn main {
    3
    use x {
        x <- { 4 3 }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:9: Cannot assign 2 value(s) to 1 variable(s)
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: assign local variable fail not enough values

fn main {
    3
    use x {
        x <- { nop }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:9: Cannot assign 0 value(s) to 1 variable(s)
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: assign local variable fail wrong type

fn main {
    3
    use x {
        x <- { false }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:9: Cannot set variable x, due to invalid type.
/// Expected: int
///    Found: bool
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: assign local variable fail non existing variable

fn main {
    3
    use x {
        y <- { 3 }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:4:9: Cannot set variable y, because it doesn't exist.
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: assign argument ok

fn main {
    nop
}

fn foo args x as int {
    x <- { 3 }
}

/// ----------------------------------------------------------------------------

/// name: get function ok builtin

fn main {
    "+" fn drop
}

/// ----------------------------------------------------------------------------

/// name: get function ok custom returning

fn main {
    "main" fn drop
}

/// ----------------------------------------------------------------------------

/// name: get function ok custom non-returning

fn never_returns return never {
    1 exit
}

fn main {
    "never_returns" fn drop
}

/// ----------------------------------------------------------------------------

/// name: get function fail non existent

fn main {
    "foo" fn drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Cannot get function foo, it does not exist.
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: get function fail not a function

fn main {
    "int" fn drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Cannot get function int, found struct int instead.
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail empty stack

enum Foo {
    foo,
}

fn main {
    match {
        default {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:5: Cannot match on an empty stack
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail non-enum

fn main {
    3
    match {
        default {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:3:5: Cannot match on struct int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail unexpected enum

enum Foo {
    foo,
}

enum Bar {
    bar,
}

fn main {
    Foo
    match {
        case Bar:bar {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:10:9: Unexpected enum case:
/// Expected: Foo
///    Found: Bar
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail repeated case

enum Foo {
    foo,
}

fn main {
    Foo
    match {
        case Foo:foo {
            nop
        }
        case Foo:foo {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// Found colliding case blocks:
/// $SOURCE_PATH/main.aaa:7:9: case Foo:foo
/// $SOURCE_PATH/main.aaa:10:9: case Foo:foo
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail repeated default

enum Foo {
    foo,
}

fn main {
    Foo
    match {
        default {
            nop
        }
        default {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// Found colliding default blocks:
/// $SOURCE_PATH/main.aaa:7:9: default
/// $SOURCE_PATH/main.aaa:10:9: default
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail missing case

enum FooBar {
    foo,
    bar,
}

fn main {
    FooBar
    match {
        case FooBar:foo {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:7:5: Some enum variant(s) are unhandled:
/// case FooBar:bar
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail unreachable default

enum Foo {
    foo,
}

fn main {
    Foo
    match {
        case Foo:foo {
            nop
        }
        default {
            nop
        }
    }
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:10:9: Default block is unreachable
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail inconsistent child stacks

enum FooBar {
    foo,
    bar,
}

fn main {
    FooBar
    match {
        case FooBar:foo {
            false
        }
        case FooBar:bar {
            3
        }
    }
    drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:7:5: Children of match have inconsistent stacks:
/// case FooBar:foo: bool
/// case FooBar:bar: int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail unexpected variable expecting multiple

enum Foo {
    foo as { int, int },
}

fn main {
    Foo
    match {
        case Foo:foo as x {
            nop
        }
    }
    drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:7:9: Unexpected amount of variables for case Foo:foo:
/// Expected: 0 or 2
///    Found: 1
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail unexpected variable expecting none

enum Foo {
    foo,
}

fn main {
    Foo
    match {
        case Foo:foo as x {
            nop
        }
    }
    drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:7:9: Unexpected amount of variables for case Foo:foo:
/// Expected: 0
///    Found: 1
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail var name collision

enum Foo {
    foo as int,
}

fn main {
    3
    use x {
        Foo
        match {
            case Foo:foo as x {
                nop
            }
        }
    }
}

/// status: 1

/// stderr:
/// Found name collision:
/// $SOURCE_PATH/main.aaa:6:9: local variable x
/// $SOURCE_PATH/main.aaa:9:29: local variable x
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match fail unreachable code afterwards

enum Foo {
    foo,
}

fn main {
    Foo
    match {
        case Foo:foo {
            todo
        }
    }
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:11:5: Code is unreachable
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: match ok simple

enum FooBar {
    foo as int,
    bar,
}

fn main {
    FooBar
    match {
        case FooBar:foo as x {
            3 x +
        }
        case FooBar:bar {
            6 9 +
        }
    }
    drop
}

/// ----------------------------------------------------------------------------

/// name: match ok with never

enum FooBar {
    foo as int,
    bar,
}

fn main {
    FooBar
    match {
        case FooBar:foo as x {
            3 x +
        }
        case FooBar:bar {
            todo
        }
    }
    drop
}

/// ----------------------------------------------------------------------------

/// name: member function ok

struct Foo {}

fn Foo:bar args foo as Foo {
    nop
}

fn main {
    nop
}

/// ----------------------------------------------------------------------------

/// name: member function fail missing argument

struct Foo {}

fn Foo:bar {
    nop
}

fn main {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:1: Member function Foo:bar should have associated type as first argument
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: member function fail invalid first argument

struct Foo {}

fn Foo:bar args baz as fn[][] {
    nop
}

fn main {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:1: Invalid first argument of member function Foo:bar
/// Expected: struct or enum
///    Found: fn[][]
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: member function fail unexpected first argument type

struct Foo {}

fn Foo:bar args baz as int {
    nop
}

fn main {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:1: First argument of member function Foo:bar has unexpected type
/// Expected: Foo
///    Found: int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: main signature ok basic

fn main {
    nop
}

/// ----------------------------------------------------------------------------

/// name: main signature ok with argument

fn main args argv as vec[str] {
    nop
}

/// ----------------------------------------------------------------------------

/// name: main signature ok with arguments and return type

fn main args argv as vec[str] return int {
    0
}

/// ----------------------------------------------------------------------------

/// name: main signature with return type

fn main return int {
    0
}

/// ----------------------------------------------------------------------------

/// name: main signature fail with argument

fn main args argv as int {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: Main function has wrong signature, it should have:
/// - no type parameters
/// - either no arguments or one vec[str] argument
/// - return either nothing or an int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: main signature fail with argument parameter

fn main args argv as vec[int] {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: Main function has wrong signature, it should have:
/// - no type parameters
/// - either no arguments or one vec[str] argument
/// - return either nothing or an int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: main signature fail with argument amount

fn main args argv as vec[str], extra as int {
    nop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: Main function has wrong signature, it should have:
/// - no type parameters
/// - either no arguments or one vec[str] argument
/// - return either nothing or an int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: main signature fail with return type

fn main return str {
    ""
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: Main function has wrong signature, it should have:
/// - no type parameters
/// - either no arguments or one vec[str] argument
/// - return either nothing or an int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: main signature fail with return type amount

fn main return int, str {
    0 ""
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: Main function has wrong signature, it should have:
/// - no type parameters
/// - either no arguments or one vec[str] argument
/// - return either nothing or an int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: main signature fail no main function

// If we leave this out no file is being created by doctest framework
struct dummy {}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa: No main function found
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: main not a function

struct main {}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:1:1: main should be a function, found struct main instead.
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: set struct field with type param ok

struct Foo[T] {
    foo as T
}

fn main {
    Foo[int]
    "foo" { 69 } !
}

/// ----------------------------------------------------------------------------

/// name: set struct field with type param fail

struct Foo[T] {
    foo as T
}

fn main {
    Foo[int]
    "foo" { false } !
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:6:5: Invalid stack types when setting field foo on struct Foo:
///    Found: bool
/// Expected: int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: get struct field with type param ok

struct Foo[T] {
    foo as T
}

fn main {
    Foo[int]
    dup "foo" { 69 } !
    "foo" ?
    69 =
    drop
}

/// ----------------------------------------------------------------------------

/// name: get struct field with type param fail

struct Foo[T] {
    foo as T
}

fn main {
    Foo[int]
    dup "foo" { 69 } !
    "foo" ?
    false =
    drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:8:11: Invalid stack when calling =
///        stack: int bool
/// expected top: A A
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: enum with type parameter and make function

enum Foo[F] {
    foo as F,
}

fn make_foo[T] args foo as T return Foo[T] {
    foo Foo[T]:foo
}

fn main {
    3 make_foo drop
}

/// ----------------------------------------------------------------------------

/// name: enum constructor call with missing parameters

enum Foo[int] {
    foo
}

fn main {
    Foo:foo drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:5: Unexpected number of parameters
///    Found: 0
/// Expected: 1
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call ok

fn is_nice args x as int return bool {
    x 69 =
}

fn main {
    420 "is_nice" fn call
    not assert
}

/// ----------------------------------------------------------------------------

/// name: call fail wrong argument

fn is_nice args x as int return bool {
    x 69 =
}

fn main {
    false "is_nice" fn call
    not assert
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:5:24: Invalid stack when calling function pointer
///        stack: bool
/// expected top: int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call fail use return type incorrectly

fn is_nice args x as int return bool {
    x 69 =
}

fn main {
    420 "is_nice" fn call
    1 +
    drop
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:6:7: Invalid stack when calling +
///        stack: bool int
/// expected top: int int
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call fail empty stack

fn main {
    call
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:5: Stack underflow when using call
///        stack:
/// expected top: <function pointer>
///
/// Found 1 errors

/// ----------------------------------------------------------------------------

/// name: call fail non-function

fn main {
    3 call
}

/// status: 1

/// stderr:
/// $SOURCE_PATH/main.aaa:2:7: call should be used on a function pointer, found int instead.
///
/// Found 1 errors
