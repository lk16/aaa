// TODO create models file
from "tokenizer" import
    FileReadResult,
    make_tokenizer,
    OptionalToken,
    Position,
    print_tokens,
    read_file,
    Token,
    Tokenizer,
    TokenizeResult,
    TokenType,

struct BooleanLiteral { // TODO rename to Boolean
    value as bool,
    position as Position,
}

struct IntegerLiteral { // TODO rename to Integer
    value as int,
    position as Position,
}

struct StringLiteral { // TODO rename to String
    value as str,
    position as Position,
}

struct Identifier {
    value as str,
    position as Position,
}

struct Return {
    position as Position,
}

struct StructFieldQuery {
    position as Position,
    field_name as str,
}

struct StructFieldUpdate {
    position as Position,
    field_name as str,
    body as FunctionBody,
}

struct Branch {
    condition as FunctionBody,
    if_body as FunctionBody,
    else_body as OptionalFunctionBody,
}

struct WhileLoop {
    condition as FunctionBody,
    body as FunctionBody,
}

struct ForeachLoop {
    position as Position,
    body as FunctionBody,
}

struct UseBlock {
    position as Position,
    // TODO
}

struct MatchBlock {
    position as Position,
    // TODO
}

struct Assignment {
    position as Position,
    // TODO
}

struct Call {
    position as Position,
    // TODO
}

struct FunctionBody {
    position as Position,
    items as vec[FunctionBodyItem],
}

enum FunctionBodyItem {
    string as StringLiteral,
    struct_field_query as StructFieldQuery,
    struct_field_update as StructFieldUpdate,
    boolean as BooleanLiteral,
    integer as IntegerLiteral,
    assignment as Assignment,
    call as Call,
    branch as Branch,
    while_loop as WhileLoop,
    foreach_loop as ForeachLoop,
    use_block as UseBlock,
    match_block as MatchBlock,
    return_ as Return,
}

fn make_boolean_parse_result args token as Token, next_offset as int return BooleanParseResult {
    BooleanLiteral
    dup "value" { token "value" ? "true" str:equals } !
    dup "position" { token "position" ? copy swap drop } !
    next_offset
    BooleanParseResult:ok
}

fn make_integer_parse_result args token as Token, next_offset as int return IntegerParseResult {
    token "value" ? str:to_int
    use value, ok {
        if ok not {
            IntegerParseResult:err return
        }

        IntegerLiteral
        dup "value" { value } !
        dup "position" { token "position" ? copy swap drop } !
        next_offset
        IntegerParseResult:ok
    }
}

fn make_string_parse_result args token as Token, next_offset as int return StringParseResult {
    token "value" ?

    use value {
        value <- { value 1 value str:len 1 - str:substr drop }
        value <- { value "\\\\" "\\" str:replace }
        value <- { value "\\n" "\n" str:replace }
        value <- { value "\\r" "\r" str:replace }
        value <- { value "\\\"" "\"" str:replace }

        StringLiteral
        dup "value" { value } !
        dup "position" { token "position" ? copy swap drop } !
        next_offset
        StringParseResult:ok
    }
}

fn make_identifier_parse_result args token as Token, next_offset as int return IdentifierParseResult {
    Identifier
    dup "value" {  token "value" ? } !
    dup "position" { token "position" ? copy swap drop } !
    next_offset
    IdentifierParseResult:ok
}

fn make_return_parse_result args token as Token, next_offset as int return ReturnParseResult {
    Return
    dup "position" { token "position" ? copy swap drop } !
    next_offset
    ReturnParseResult:ok
}

fn make_function_body args items as vec[FunctionBodyItem], next_offset as int return FunctionBody {
    FunctionBody
    dup "items" { items } !
}

fn make_branch args condition as FunctionBody, if_body as FunctionBody, else_body as OptionalFunctionBody return Branch {
    Branch
    dup "condition" { condition } !
    dup "if_body" { if_body } !
    dup "else_body" { else_body } !
}

fn make_while_loop args condition as FunctionBody, body as FunctionBody return WhileLoop {
    WhileLoop
    dup "condition" { condition } !
    dup "body" { body } !
}

fn make_foreach_loop args body as FunctionBody return ForeachLoop {
    ForeachLoop
    dup "body" { body } !
}

fn make_struct_field_query args field_name as str return StructFieldQuery {
    StructFieldQuery
    dup "field_name" { field_name } !
}

fn make_struct_field_update args field_name as str, body as FunctionBody return StructFieldUpdate {
    StructFieldUpdate
    dup "field_name" { field_name } !
    dup "body" { body } !
}

enum BooleanParseResult {
    err,  // TODO change to Position
    ok as { BooleanLiteral, int },
}

enum IntegerParseResult {
    err,
    ok as { IntegerLiteral, int },
}

enum StringParseResult {
    err,
    ok as { StringLiteral, int },
}

enum IdentifierParseResult {
    err,
    ok as { Identifier, int },
}

enum ReturnParseResult {
    err,
    ok as { Return, int },
}

enum AssignmentParseResult {
    err,
    ok as { Assignment, int },
}

enum CallParseResult {
    err,
    ok as { Call, int },
}

enum BranchParseResult {
    err,
    ok as { Branch, int },
}

enum WhileLoopParseResult {
    err,
    ok as { WhileLoop, int },
}

enum ForeachLoopParseResult {
    err,
    ok as { ForeachLoop, int },
}

enum UseBlockParseResult {
    err,
    ok as { UseBlock, int },
}

enum MatchBlockParseResult {
    err,
    ok as { MatchBlock, int },
}

enum FunctionBodyItemParseResult {
    err,
    ok as { FunctionBodyItem, int },
}

enum FunctionBodyParseResult {
    err,
    ok as { FunctionBody, int },
}

enum StructFieldQueryResult {
    err,
    ok as { StructFieldQuery, int },
}

enum StructFieldUpdateResult {
    err,
    ok as { StructFieldUpdate, int },
}

enum OptionalFunctionBody {
    none,
    some as FunctionBody,
}

struct Parser {
    tokens as vec[Token],
}

fn make_parser args tokens as vec[Token] return Parser {
    Parser
    dup "tokens" { tokens } !
}

fn Parser:run args parser as Parser {
    "running parser!\n" .
}

fn Parser:get_token args parser as Parser, offset as int return OptionalToken {
    parser "tokens" ?
    use tokens {
        if tokens vec:len offset <= {
            OptionalToken:none
        } else {
            tokens offset vec:get OptionalToken:some
        }
    }
}

fn Parser:parse_boolean args parser as Parser, offset as int return BooleanParseResult {
    parser offset Parser:get_token
    match {
        case OptionalToken:none { BooleanParseResult:err return }
        case OptionalToken:some { nop }
    }

    use token {
        token "type_" ?
        match {
            case TokenType:false_ { nop }
            case TokenType:true_ { nop }
            default { BooleanParseResult:err return }
        }

        token offset 1 + make_boolean_parse_result
    }
}

fn Parser:parse_integer args parser as Parser, offset as int return IntegerParseResult {
    parser offset Parser:get_token
    match {
        case OptionalToken:none { IntegerParseResult:err return }
        case OptionalToken:some { nop }
    }

    use token {
        token "type_" ?
        match {
            case TokenType:integer { token offset 1 + make_integer_parse_result }
            default { IntegerParseResult:err }
        }
    }
}

fn Parser:parse_string args parser as Parser, offset as int return StringParseResult {
    parser offset Parser:get_token
    match {
        case OptionalToken:none { StringParseResult:err return }
        case OptionalToken:some { nop }
    }

    use token {
        token "type_" ?
        match {
            case TokenType:string { token offset 1 + make_string_parse_result }
            default { StringParseResult:err }
        }
    }
}

fn Parser:parse_identifier args parser as Parser, offset as int return IdentifierParseResult {
    parser offset Parser:get_token
    match {
        case OptionalToken:none { IdentifierParseResult:err return }
        case OptionalToken:some { nop }
    }

    use token {
        token "type_" ?
        match {
            case TokenType:identifier { token offset 1 + make_identifier_parse_result }
            default { IdentifierParseResult:err }
        }
    }
}

fn Parser:parse_return args parser as Parser, offset as int, return ReturnParseResult {
    parser offset Parser:get_token
    match {
        case OptionalToken:none { ReturnParseResult:err return }
        case OptionalToken:some { nop }
    }

    use token {
        token "type_" ?
        match {
            case TokenType:return_ { token offset 1 + make_return_parse_result }
            default { ReturnParseResult:err }
        }
    }
}

fn Parser:parse_function_body_item args parser as Parser, offset as int return FunctionBodyItemParseResult {
    parser offset Parser:get_token
    match {
        case OptionalToken:none { FunctionBodyItemParseResult:err return }
        case OptionalToken:some { nop }
    }

    use token {
        token "type_" ?
        match {
            case TokenType:string {
                parser offset 1 + Parser:get_token
                match {
                    case OptionalToken:none { nop }
                    case OptionalToken:some as next_token {
                        next_token "type_" ?
                        match {
                            case TokenType:get_field {
                                parser offset Parser:parse_struct_field_query
                                match {
                                    case StructFieldQueryResult:ok as query, next_offset {
                                        query FunctionBodyItem:struct_field_query
                                        next_offset FunctionBodyItemParseResult:ok
                                    }
                                    case StructFieldQueryResult:err {
                                        FunctionBodyItemParseResult:err
                                    }
                                }
                                return
                            }
                            case TokenType:begin {
                                parser offset Parser:parse_struct_field_update
                                match {
                                    case StructFieldUpdateResult:ok as update, next_offset {
                                        update FunctionBodyItem:struct_field_update
                                        next_offset FunctionBodyItemParseResult:ok
                                    }
                                    case StructFieldUpdateResult:err {
                                        FunctionBodyItemParseResult:err
                                    }
                                }
                                return
                            }
                            default { nop }
                        }
                    }
                }
                parser offset Parser:parse_string
                match {
                    case StringParseResult:ok as string, next_offset {
                        string FunctionBodyItem:string
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case StringParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:true_ {
                parser offset Parser:parse_boolean
                match {
                    case BooleanParseResult:ok as boolean, next_offset {
                        boolean FunctionBodyItem:boolean
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case BooleanParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:false_ {
                parser offset Parser:parse_boolean
                match {
                    case BooleanParseResult:ok as boolean, next_offset {
                        boolean FunctionBodyItem:boolean
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case BooleanParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:integer {
                parser offset Parser:parse_integer
                match {
                    case IntegerParseResult:ok as integer, next_offset {
                        integer FunctionBodyItem:integer
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case IntegerParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:identifier {
                parser offset 1 + Parser:get_token
                match {
                    case OptionalToken:none { nop }
                    case OptionalToken:some as next_token {
                        next_token "type_" ?
                        match {
                            case TokenType:comma {
                                parser offset Parser:parse_assignment
                                match {
                                    case AssignmentParseResult:ok as assignment, next_offset {
                                        assignment FunctionBodyItem:assignment
                                        next_offset FunctionBodyItemParseResult:ok
                                    }
                                    case AssignmentParseResult:err {
                                        FunctionBodyItemParseResult:err
                                    }
                                }
                                return
                            }
                            case TokenType:assign {
                                parser offset Parser:parse_assignment
                                match {
                                    case AssignmentParseResult:ok as assignment, next_offset {
                                        assignment FunctionBodyItem:assignment
                                        next_offset FunctionBodyItemParseResult:ok
                                    }
                                    case AssignmentParseResult:err {
                                        FunctionBodyItemParseResult:err
                                    }
                                }
                                return
                            }
                            default { nop }
                        }
                    }
                }

                parser offset Parser:parse_call
                match {
                    case CallParseResult:ok as call, next_offset {
                        call FunctionBodyItem:call
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case CallParseResult:err {
                        FunctionBodyItemParseResult:err
                    }
                }
            }
            case TokenType:if_ {
                parser offset Parser:parse_branch
                match {
                    case BranchParseResult:ok as branch, next_offset {
                        branch FunctionBodyItem:branch
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case BranchParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:while_ {
                parser offset Parser:parse_while_loop
                match {
                    case WhileLoopParseResult:ok as loop, next_offset {
                        loop FunctionBodyItem:while_loop
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case WhileLoopParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:foreach_ {
                parser offset Parser:parse_foreach_loop
                match {
                    case ForeachLoopParseResult:ok as loop, next_offset {
                        loop FunctionBodyItem:foreach_loop
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case ForeachLoopParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:use_ {
                parser offset Parser:parse_use_block
                match {
                    case UseBlockParseResult:ok as use_block, next_offset {
                        use_block FunctionBodyItem:use_block
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case UseBlockParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:match_ {
                parser offset Parser:parse_match_block
                match {
                    case MatchBlockParseResult:ok as match_block, next_offset {
                        match_block FunctionBodyItem:match_block
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case MatchBlockParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            case TokenType:return_ {
                parser offset Parser:parse_return
                match {
                    case ReturnParseResult:ok as return_, next_offset {
                        return_ FunctionBodyItem:return_
                        next_offset FunctionBodyItemParseResult:ok
                    }
                    case ReturnParseResult:err { FunctionBodyItemParseResult:err }
                }
            }
            default { FunctionBodyItemParseResult:err }
        }
    }
}

fn Parser:parse_function_body args parser as Parser, offset as int return FunctionBodyParseResult {
    vec[FunctionBodyItem]
    use items {
        while true {
            parser offset Parser:parse_function_body_item
            match {
                case FunctionBodyItemParseResult:err {
                    if items vec:empty {
                        FunctionBodyParseResult:err
                    } else {
                        items offset make_function_body offset FunctionBodyParseResult:ok
                    }
                    return
                }
                case FunctionBodyItemParseResult:ok as item, item_offset {
                    offset <- { item_offset }
                    items item vec:push
                }
            }
        }
    }
}

fn Parser:has_token_type args parser as Parser, offset as int, token_type as str return bool {
    parser offset Parser:get_token
    match {
        case OptionalToken:none { false }
        case OptionalToken:some as token {
            token "type_" ? TokenType:to_str token_type str:equals
        }
    }
}

fn Parser:parse_branch args parser as Parser, offset as int return BranchParseResult {
    if parser offset "IF" Parser:has_token_type not {
        BranchParseResult:err return
    }

    offset <- { offset 1 + }

    parser offset Parser:parse_function_body
    match {
        case FunctionBodyParseResult:ok { nop }
        default { BranchParseResult:err return }
    }

    use condition, condition_offset {
        offset <- { condition_offset }

        if parser offset "BEGIN" Parser:has_token_type not {
            BranchParseResult:err return
        }

        offset <- { offset 1 + }

        parser offset Parser:parse_function_body
        match {
            case FunctionBodyParseResult:ok { nop }
            default { BranchParseResult:err return }
        }

        OptionalFunctionBody:none
        use if_body, if_body_offset, else_body {
            offset <- { if_body_offset }

            if parser offset "END" Parser:has_token_type not {
                BranchParseResult:err return
            }

            offset <- { offset 1 + }

            if parser offset "ELSE" Parser:has_token_type {
                offset <- { offset 1 + }

                if parser offset "BEGIN" Parser:has_token_type not {
                    BranchParseResult:err return
                }

                offset <- { offset 1 + }

                parser offset Parser:parse_function_body

                match {
                    case FunctionBodyParseResult:ok as body, body_offset {
                        else_body <- { body OptionalFunctionBody:some }
                        offset <- { body_offset }
                    }
                    default { BranchParseResult:err return }
                }

                if parser offset "END" Parser:has_token_type not {
                    BranchParseResult:err return
                }

                offset <- { offset 1 + }
            }

            condition if_body else_body make_branch
            offset
            BranchParseResult:ok
        }
    }
}

fn Parser:parse_while_loop args parser as Parser, offset as int return WhileLoopParseResult {
    if parser offset "WHILE" Parser:has_token_type not {
        WhileLoopParseResult:err return
    }

    offset <- { offset 1 + }

    parser offset Parser:parse_function_body
    match {
        case FunctionBodyParseResult:ok { nop }
        default { WhileLoopParseResult:err return }
    }

    use condition, condition_offset {
        offset <- { condition_offset }

        if parser offset "BEGIN" Parser:has_token_type not {
            WhileLoopParseResult:err return
        }

        offset <- { offset 1 + }

        parser offset Parser:parse_function_body
        match {
            case FunctionBodyParseResult:ok { nop }
            default { WhileLoopParseResult:err return }
        }

        use body, body_offset {
            offset <- { body_offset }

            if parser offset "END" Parser:has_token_type not {
                WhileLoopParseResult:err return
            }

            offset <- { offset 1 + }

            condition body make_while_loop offset WhileLoopParseResult:ok
        }
    }
}

fn Parser:parse_foreach_loop args parser as Parser, offset as int return ForeachLoopParseResult {
    if parser offset "FOREACH" Parser:has_token_type not {
        ForeachLoopParseResult:err return
    }

    offset <- { offset 1 + }

    if parser offset "BEGIN" Parser:has_token_type not {
        ForeachLoopParseResult:err return
    }

    offset <- { offset 1 + }

    parser offset Parser:parse_function_body
    match {
        case FunctionBodyParseResult:ok { nop }
        default { ForeachLoopParseResult:err return }
    }

    use body, body_offset {
        offset <- { body_offset }

        if parser offset "END" Parser:has_token_type not {
            ForeachLoopParseResult:err return
        }

        offset <- { offset 1 + }

        body make_foreach_loop offset ForeachLoopParseResult:ok
    }
}

fn Parser:parse_struct_field_query args parser as Parser, offset as int return StructFieldQueryResult {
    parser offset Parser:parse_string
    match {
        case StringParseResult:err { StructFieldQueryResult:err return }
        case StringParseResult:ok { nop }
    }

    use field_name_literal, field_name_offset {
        offset <- { field_name_offset }

        if parser offset "GET_FIELD" Parser:has_token_type not {
            StructFieldQueryResult:err return
        }

        offset <- { offset 1 + }

        field_name_literal "value" ?
        use field_name {
            field_name make_struct_field_query offset StructFieldQueryResult:ok
        }
    }
}

fn Parser:parse_struct_field_update args parser as Parser, offset as int return StructFieldUpdateResult {
    parser offset Parser:parse_string
    match {
        case StringParseResult:err { StructFieldUpdateResult:err return }
        case StringParseResult:ok { nop }
    }

    use field_name_literal, field_name_offset {
        offset <- { field_name_offset }

        if parser offset "BEGIN" Parser:has_token_type not {
                StructFieldUpdateResult:err return
        }

        offset <- { offset 1 + }

        parser offset Parser:parse_function_body
        match {
            case FunctionBodyParseResult:err { StructFieldUpdateResult:err return }
            case FunctionBodyParseResult:ok { nop }
        }

        use body, body_offset {
            offset <- { body_offset }

            if parser offset "END" Parser:has_token_type not {
                StructFieldUpdateResult:err return
            }

            offset <- { offset 1 + }

            if parser offset "SET_FIELD" Parser:has_token_type not {
                StructFieldUpdateResult:err return
            }

            offset <- { offset 1 + }

            field_name_literal "value" ?
            use field_name {
                field_name body make_struct_field_update offset StructFieldUpdateResult:ok
            }
        }
    }
}

fn Parser:parse_case_block args parser as Parser, offset as int { todo }
fn Parser:parse_default_block args parser as Parser, offset as int { todo }
fn Parser:parse_match_block args parser as Parser, offset as int return MatchBlockParseResult { todo }
fn Parser:parse_enum_variant args parser as Parser, offset as int { todo }
fn Parser:parse_enum_variants args parser as Parser, offset as int { todo }
fn Parser:parse_enum_definition args parser as Parser, offset as int { todo }
fn Parser:parse_variables args parser as Parser, offset as int { todo }
fn Parser:parse_use_block args parser as Parser, offset as int return UseBlockParseResult { todo }
fn Parser:parse_assignment args parser as Parser, offset as int return AssignmentParseResult { todo }
fn Parser:parse_call args parser as Parser, offset as int return CallParseResult { todo }
fn Parser:parse_function_name args parser as Parser, offset as int { todo }
fn Parser:parse_function_declaration args parser as Parser, offset as int { todo }
fn Parser:parse_function_definition args parser as Parser, offset as int { todo }

fn Parser:parse_type_literal args parser as Parser, offset as int { todo }
fn Parser:parse_type_params args parser as Parser, offset as int { todo }
fn Parser:parse_argument args parser as Parser, offset as int { todo }
fn Parser:parse_arguments args parser as Parser, offset as int { todo }
fn Parser:parse_return_types args parser as Parser, offset as int { todo }

fn Parser:parse_import_item args parser as Parser, offset as int { todo }
fn Parser:parse_import_items args parser as Parser, offset as int { todo }
fn Parser:parse_import_statement args parser as Parser, offset as int { todo }

fn Parser:parse_struct_definition args parser as Parser, offset as int { todo }
fn Parser:parse_flat_type_params args parser as Parser, offset as int { todo }
fn Parser:parse_flat_type_literal args parser as Parser, offset as int { todo }
fn Parser:parse_type_declaration args parser as Parser, offset as int { todo }
fn Parser:parse_builtins_file_root args parser as Parser, offset as int { todo }
fn Parser:parse_regular_file_root args parser as Parser, offset as int { todo }

fn main args argv as vec[str] return int {
    // TODO move duplicate code out, it's similar to tokenizer main

    if argv vec:len 2 != {
        "Usage: " .
        argv 0 vec:get .
        " <source_file>\n" .
        1 return
    }

    argv 1 vec:get

    use source_path {
        source_path read_file
        match {
            case FileReadResult:open_error {
                "Could not open " . source_path . "\n" .
                1 return
            }
            case FileReadResult:read_error {
                "Could not read " . source_path . "\n" .
                1 return
            }
            case FileReadResult:ok as content {
                source_path content make_tokenizer Tokenizer:run
                match {
                    case TokenizeResult:ok as tokens {
                        tokens make_parser Parser:run
                    }
                    case TokenizeResult:error {
                        "Tokenization failed.\n" .
                        1 return
                    }
                }
            }
        }
    }

    0
}
